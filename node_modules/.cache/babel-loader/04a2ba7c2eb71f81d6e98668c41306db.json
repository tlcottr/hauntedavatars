{"ast":null,"code":"// Defaults\nvar defaultOptions = {\n  format: 'image/png',\n  quality: 0.92,\n  width: undefined,\n  height: undefined,\n  Canvas: undefined,\n  crossOrigin: undefined\n};\n\n// Return Promise\nvar mergeImages = function mergeImages(sources, options) {\n  if (sources === void 0) sources = [];\n  if (options === void 0) options = {};\n  return new Promise(function (resolve) {\n    options = Object.assign({}, defaultOptions, options);\n\n    // Setup browser/Node.js specific variables\n    var canvas = options.Canvas ? new options.Canvas() : window.document.createElement('canvas');\n    var Image = options.Image || window.Image;\n\n    // Load sources\n    var images = sources.map(function (source) {\n      return new Promise(function (resolve, reject) {\n        // Convert sources to objects\n        if (source.constructor.name !== 'Object') {\n          source = {\n            src: source\n          };\n        }\n\n        // Resolve source and img when loaded\n        var img = new Image();\n        img.crossOrigin = options.crossOrigin;\n        img.onerror = function () {\n          return reject(new Error('Couldn\\'t load image'));\n        };\n        img.onload = function () {\n          return resolve(Object.assign({}, source, {\n            img: img\n          }));\n        };\n        img.src = source.src;\n      });\n    });\n\n    // Get canvas context\n    var ctx = canvas.getContext('2d');\n\n    // When sources have loaded\n    resolve(Promise.all(images).then(function (images) {\n      // Set canvas dimensions\n      var getSize = function getSize(dim) {\n        return options[dim] || Math.max.apply(Math, images.map(function (image) {\n          return image.img[dim];\n        }));\n      };\n      canvas.width = getSize('width');\n      canvas.height = getSize('height');\n\n      // Draw images to canvas\n      images.forEach(function (image) {\n        ctx.globalAlpha = image.opacity ? image.opacity : 1;\n        return ctx.drawImage(image.img, image.x || 0, image.y || 0);\n      });\n      if (options.Canvas && options.format === 'image/jpeg') {\n        // Resolve data URI for node-canvas jpeg async\n        return new Promise(function (resolve, reject) {\n          canvas.toDataURL(options.format, {\n            quality: options.quality,\n            progressive: false\n          }, function (err, jpeg) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(jpeg);\n          });\n        });\n      }\n\n      // Resolve all other data URIs sync\n      return canvas.toDataURL(options.format, options.quality);\n    }));\n  });\n};\nexport default mergeImages;","map":{"version":3,"mappings":"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","names":["const","defaultOptions","format","quality","width","undefined","height","Canvas","crossOrigin","mergeImages","sources","options","Promise","resolve","Object","assign","canvas","window","document","createElement","Image","images","map","source","reject","constructor","name","src","img","onerror","Error","onload","ctx","getContext","all","then","getSize","dim","Math","max","image","forEach","globalAlpha","opacity","drawImage","x","y","toDataURL","progressive","err","jpeg"],"sources":["/Users/taylorcottrell/Desktop/Builds/hauntedavatars/node_modules/merge-images/src/index.js"],"sourcesContent":["// Defaults\nconst defaultOptions = {\n\tformat: 'image/png',\n\tquality: 0.92,\n\twidth: undefined,\n\theight: undefined,\n\tCanvas: undefined,\n\tcrossOrigin: undefined\n};\n\n// Return Promise\nconst mergeImages = (sources = [], options = {}) => new Promise(resolve => {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\t// Setup browser/Node.js specific variables\n\tconst canvas = options.Canvas ? new options.Canvas() : window.document.createElement('canvas');\n\tconst Image = options.Image || window.Image;\n\n\t// Load sources\n\tconst images = sources.map(source => new Promise((resolve, reject) => {\n\t\t// Convert sources to objects\n\t\tif (source.constructor.name !== 'Object') {\n\t\t\tsource = { src: source };\n\t\t}\n\n\t\t// Resolve source and img when loaded\n\t\tconst img = new Image();\n\t\timg.crossOrigin = options.crossOrigin;\n\t\timg.onerror = () => reject(new Error('Couldn\\'t load image'));\n\t\timg.onload = () => resolve(Object.assign({}, source, { img }));\n\t\timg.src = source.src;\n\t}));\n\n\t// Get canvas context\n\tconst ctx = canvas.getContext('2d');\n\n\t// When sources have loaded\n\tresolve(Promise.all(images)\n\t\t.then(images => {\n\t\t\t// Set canvas dimensions\n\t\t\tconst getSize = dim => options[dim] || Math.max(...images.map(image => image.img[dim]));\n\t\t\tcanvas.width = getSize('width');\n\t\t\tcanvas.height = getSize('height');\n\n\t\t\t// Draw images to canvas\n\t\t\timages.forEach(image => {\n\t\t\t\tctx.globalAlpha = image.opacity ? image.opacity : 1;\n\t\t\t\treturn ctx.drawImage(image.img, image.x || 0, image.y || 0);\n\t\t\t});\n\n\t\t\tif (options.Canvas && options.format === 'image/jpeg') {\n\t\t\t\t// Resolve data URI for node-canvas jpeg async\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tcanvas.toDataURL(options.format, {\n\t\t\t\t\t\tquality: options.quality,\n\t\t\t\t\t\tprogressive: false\n\t\t\t\t\t}, (err, jpeg) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(jpeg);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve all other data URIs sync\n\t\t\treturn canvas.toDataURL(options.format, options.quality);\n\t\t}));\n});\n\nexport default mergeImages;\n"]},"metadata":{},"sourceType":"module"}